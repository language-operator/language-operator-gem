#!/usr/bin/env ruby
# frozen_string_literal: true

# OAuth Callback Agent Example
#
# This example shows how to create an agent that handles OAuth 2.0 callbacks
# from various providers (GitHub, Google, etc.).
#
# Setup:
# 1. Set OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET environment variables
# 2. Configure OAuth provider redirect URI to https://<agent-url>/oauth/callback
# 3. Set OAUTH_STATE_SECRET for state parameter verification
#
# OAuth 2.0 flow:
# 1. User clicks "Login with Provider" -> redirected to provider
# 2. User authorizes -> provider redirects to /oauth/callback with code
# 3. Agent exchanges code for access token
# 4. Agent fetches user info and creates session

require 'bundler/setup'
require 'language_operator'
require 'net/http'
require 'uri'

LanguageOperator::Dsl.define_agents do
  agent 'oauth-handler' do
    description 'Handles OAuth callbacks and manages user authentication'

    # Set to reactive mode to receive callbacks
    mode :reactive

    # GitHub OAuth callback
    webhook '/oauth/github/callback' do
      method :get

      # Validate state parameter to prevent CSRF attacks
      validate do |context|
        state = context[:params]['state']
        return 'Missing state parameter' unless state

        # In production, verify state was generated by your app
        # and hasn't been used before (store in Redis/database)
        expected_state = ENV['OAUTH_STATE_SECRET']
        return 'Invalid state parameter' unless state == expected_state

        true
      end

      on_request do |context|
        code = context[:params]['code']
        error = context[:params]['error']

        # Handle OAuth errors
        if error
          return {
            status: 'error',
            error: error,
            error_description: context[:params]['error_description'],
            message: 'OAuth authorization failed'
          }
        end

        # Exchange authorization code for access token
        token_response = exchange_code_for_token(
          code: code,
          client_id: ENV['GITHUB_CLIENT_ID'],
          client_secret: ENV['GITHUB_CLIENT_SECRET'],
          token_url: 'https://github.com/login/oauth/access_token'
        )

        if token_response[:error]
          return {
            status: 'error',
            error: token_response[:error],
            message: 'Failed to exchange code for token'
          }
        end

        access_token = token_response[:access_token]

        # Fetch user info from GitHub
        user_info = fetch_github_user(access_token)

        {
          status: 'success',
          message: 'OAuth authentication successful',
          user: {
            id: user_info['id'],
            username: user_info['login'],
            email: user_info['email'],
            name: user_info['name']
          },
          # In production, create session/JWT here
          session_created: true
        }
      end
    end

    # Google OAuth callback
    webhook '/oauth/google/callback' do
      method :get

      validate do |context|
        state = context[:params]['state']
        return 'Missing state parameter' unless state

        expected_state = ENV['OAUTH_STATE_SECRET']
        return 'Invalid state parameter' unless state == expected_state

        true
      end

      on_request do |context|
        code = context[:params]['code']
        error = context[:params]['error']

        if error
          return {
            status: 'error',
            error: error,
            message: 'OAuth authorization failed'
          }
        end

        # Exchange code for token
        token_response = exchange_code_for_token(
          code: code,
          client_id: ENV['GOOGLE_CLIENT_ID'],
          client_secret: ENV['GOOGLE_CLIENT_SECRET'],
          token_url: 'https://oauth2.googleapis.com/token',
          redirect_uri: ENV['GOOGLE_REDIRECT_URI']
        )

        if token_response[:error]
          return {
            status: 'error',
            error: token_response[:error],
            message: 'Failed to exchange code for token'
          }
        end

        access_token = token_response[:access_token]
        id_token = token_response[:id_token]

        # Fetch user info from Google
        user_info = fetch_google_user(access_token)

        {
          status: 'success',
          message: 'OAuth authentication successful',
          user: {
            id: user_info['id'],
            email: user_info['email'],
            name: user_info['name'],
            picture: user_info['picture']
          },
          session_created: true
        }
      end
    end

    # Generic OAuth callback with bearer token auth
    # (for testing or internal use)
    webhook '/oauth/test/callback' do
      method :post

      # Require bearer token for security
      authenticate do
        verify_bearer_token(token: ENV['OAUTH_TEST_TOKEN'])
      end

      require_content_type 'application/json'

      on_request do |context|
        data = JSON.parse(context[:body])

        {
          status: 'success',
          message: 'Test callback received',
          data: data
        }
      end
    end

    # OAuth initiation endpoint (starts the flow)
    webhook '/oauth/github/initiate' do
      method :get

      on_request do |context|
        # Generate state parameter for CSRF protection
        state = SecureRandom.hex(32)

        # In production, store state in Redis/database with expiration
        # For demo purposes, we're just using a static value

        # Build GitHub authorization URL
        params = {
          client_id: ENV['GITHUB_CLIENT_ID'],
          redirect_uri: ENV['GITHUB_REDIRECT_URI'],
          scope: 'user:email',
          state: ENV['OAUTH_STATE_SECRET'] # Use proper state in production
        }

        auth_url = "https://github.com/login/oauth/authorize?#{URI.encode_www_form(params)}"

        # Return redirect response
        [
          302,
          { 'Location' => auth_url },
          ['Redirecting to GitHub...']
        ]
      end
    end

    # Session verification endpoint
    webhook '/oauth/verify' do
      method :get

      # Verify bearer token
      authenticate do
        verify_bearer_token(token: ENV['SESSION_TOKEN'])
      end

      on_request do |_context|
        {
          status: 'valid',
          message: 'Session is valid',
          authenticated: true
        }
      end
    end
  end
end

# Helper methods

def exchange_code_for_token(code:, client_id:, client_secret:, token_url:, redirect_uri: nil)
  uri = URI(token_url)

  params = {
    code: code,
    client_id: client_id,
    client_secret: client_secret,
    grant_type: 'authorization_code'
  }
  params[:redirect_uri] = redirect_uri if redirect_uri

  request = Net::HTTP::Post.new(uri)
  request.set_form_data(params)
  request['Accept'] = 'application/json'

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
    http.request(request)
  end

  JSON.parse(response.body, symbolize_names: true)
rescue StandardError => e
  { error: e.message }
end

def fetch_github_user(access_token)
  uri = URI('https://api.github.com/user')

  request = Net::HTTP::Get.new(uri)
  request['Authorization'] = "Bearer #{access_token}"
  request['Accept'] = 'application/vnd.github.v3+json'

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
    http.request(request)
  end

  JSON.parse(response.body)
rescue StandardError => e
  { error: e.message }
end

def fetch_google_user(access_token)
  uri = URI('https://www.googleapis.com/oauth2/v2/userinfo')

  request = Net::HTTP::Get.new(uri)
  request['Authorization'] = "Bearer #{access_token}"

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
    http.request(request)
  end

  JSON.parse(response.body)
rescue StandardError => e
  { error: e.message }
end

# Run the agent if this file is executed directly
if __FILE__ == $PROGRAM_NAME
  agent = LanguageOperator::Dsl.agent_registry.get('oauth-handler')
  agent.run!
end
