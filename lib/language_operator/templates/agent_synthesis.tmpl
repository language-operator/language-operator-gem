You are generating Ruby DSL code for an autonomous agent in a Kubernetes operator.

{{if .ErrorContext}}
## IMPORTANT: Self-Healing Synthesis - Attempt {{.AttemptNumber}}

The previous code synthesis encountered errors. Please analyze the errors below and generate CORRECTED code.

### Previous Synthesis Failures

{{if .ErrorContext.ValidationErrors}}
**Validation Errors** (detected during code generation):
{{range .ErrorContext.ValidationErrors}}
- {{.}}
{{end}}
{{end}}

{{if .ErrorContext.RuntimeErrors}}
**Runtime Errors** (detected during execution):
{{range .ErrorContext.RuntimeErrors}}
- Time: {{.Timestamp}}
- Type: {{.ErrorType}}
- Message: {{.ErrorMessage}}
{{if .StackTrace}}
- Stack Trace:
{{range .StackTrace}}
  {{.}}
{{end}}
{{end}}
- Exit Code: {{.ContainerExitCode}}
{{end}}
{{end}}

{{if .ErrorContext.LastCrashLog}}
**Last Container Logs** (before crash):
```
{{.ErrorContext.LastCrashLog}}
```
{{end}}

### Your Task

1. Carefully analyze each error above
2. Identify the root cause of the failure
3. Generate CORRECTED Ruby DSL code that addresses ALL errors
4. Ensure the code:
   - Fixes the specific errors mentioned
   - Uses only available tools: {{.ToolsList}}
   - Uses only available models: {{.ModelsList}}
   - Follows the Language Operator DSL syntax exactly
   - Does NOT use any dangerous Ruby methods (system, eval, etc.)

This is attempt {{.AttemptNumber}} of {{.MaxAttempts}}. The user is counting on you to get it right!

{{if .LastKnownGoodCode}}
### Last Known Working Code (for reference)
```ruby
{{.LastKnownGoodCode}}
```
{{end}}

{{else}}
## Agent Synthesis Request
{{end}}

**User Instructions:**
{{.Instructions}}

**Available Tools:**
{{.ToolsList}}

**Available Models:**
{{.ModelsList}}

**Agent Name:** {{.AgentName}}

**Detected Temporal Intent:** {{.TemporalIntent}}

**Runtime Context:**
- All agent messages and output are automatically logged to stdout
- Agents have access to a workspace directory for file operations
- LLM responses are captured and available in agent execution context

## DSL v1 Reference Examples

Study these examples to understand the task/main model with organic functions:

### Example 1: Simple Scheduled Agent (Fully Neural)
```ruby
require 'language_operator'

agent "daily-report" do
  description "Generate daily sales report"
  mode :scheduled
  schedule "0 9 * * *"

  task :fetch_sales,
    instructions: "fetch yesterday's sales data from database",
    inputs: {},
    outputs: { sales: 'array', total: 'number' }

  task :generate_report,
    instructions: "create a markdown report summarizing the sales",
    inputs: { sales: 'array', total: 'number' },
    outputs: { report: 'string' }

  main do |inputs|
    sales_data = execute_task(:fetch_sales)
    report = execute_task(:generate_report, inputs: sales_data)
    report
  end

  output do |outputs|
    puts outputs[:report]
  end
end
```

### Example 2: Hybrid Neural-Symbolic Agent
```ruby
require 'language_operator'

agent "code-reviewer" do
  description "Review pull requests"

  # Symbolic task - deterministic tool call
  task :fetch_pr_diff do |inputs|
    {
      diff: execute_tool('github', 'get_pr_diff', pr_number: inputs[:pr_number])
    }
  end

  # Neural task - creative analysis
  task :analyze_code,
    instructions: "review code changes for bugs and improvements",
    inputs: { diff: 'string' },
    outputs: { issues: 'array', severity: 'string' }

  # Symbolic task - deterministic logic
  task :should_approve do |inputs|
    critical = inputs[:issues].select { |i| i['severity'] == 'critical' }
    { approve: critical.empty? }
  end

  main do |inputs|
    pr_data = execute_task(:fetch_pr_diff, inputs: inputs)
    analysis = execute_task(:analyze_code, inputs: pr_data)
    decision = execute_task(:should_approve, inputs: analysis)
    analysis.merge(decision)
  end
end
```

### Example 3: Multi-Step Agent with Tools
```ruby
require 'language_operator'

agent "data-pipeline" do
  description "ETL pipeline"

  task :extract_data,
    instructions: "extract data from the source database",
    inputs: { source: 'string' },
    outputs: { records: 'array', count: 'integer' }

  task :transform_data,
    instructions: "clean and normalize the records",
    inputs: { records: 'array' },
    outputs: { cleaned_records: 'array' }

  task :load_data,
    instructions: "load cleaned records into warehouse",
    inputs: { cleaned_records: 'array' },
    outputs: { success: 'boolean', loaded_count: 'integer' }

  main do |inputs|
    extracted = execute_task(:extract_data, inputs: inputs)
    transformed = execute_task(:transform_data, inputs: extracted)
    result = execute_task(:load_data, inputs: transformed)
    result
  end
end
```

## Your Task: Generate DSL v1 Agent

Using the THREE CONCRETE EXAMPLES above (daily-report, code-reviewer, data-pipeline) as reference patterns, generate WORKING Ruby DSL code for the agent described in the user instructions.

**CRITICAL REQUIREMENTS:**
- DO NOT output placeholder text like "Brief description extracted from instructions" or "CRON_EXPRESSION"
- DO NOT output generic names like `:task_name` or `param_name`
- DO NOT copy the template structure below - USE THE WORKING EXAMPLES ABOVE
- Generate ACTUAL, FUNCTIONAL code that implements the user's request
- Use SPECIFIC task names, descriptions, and logic based on the user instructions

The code structure should follow this pattern (with ACTUAL content, not placeholders):

```
require 'language_operator'

agent "{{.AgentName}}" do
  description "<ACTUAL description based on user instructions>"
{{.PersonaSection}}{{.ScheduleSection}}
  # Define specific tasks needed for this agent
  task :<ACTUAL_task_name>,
    instructions: "<ACTUAL description of what this specific task does>",
    inputs: { <actual_param>: '<actual_type>' },
    outputs: { <actual_result>: '<actual_type>' }

  # Add more tasks as needed based on user instructions

  main do |inputs|
    # ACTUAL execution flow implementing the user's request
    result = execute_task(:<ACTUAL_task_name>, inputs: { <actual_param>: <actual_value> })
    result
  end

{{.ConstraintsSection}}

  output do |outputs|
    # ACTUAL output handling for this specific agent
    puts outputs.inspect
  end
end
```

**Type System:**
- `'string'` - text values
- `'integer'` - whole numbers
- `'number'` - decimal numbers
- `'boolean'` - true/false
- `'array'` - lists
- `'hash'` - key-value objects
- `'any'` - any type

**Rules:**
1. Generate ONLY the Ruby code within triple-backticks, no explanations before or after
{{.ScheduleRules}}
3. Break down the user's instructions into SPECIFIC tasks with type-safe contracts
4. REQUIRED: Always include a `main` block that calls tasks via `execute_task()`
5. For simple deterministic tasks, use symbolic code blocks (do |inputs| ... end)
6. For complex/creative tasks, use neural tasks with instructions
7. Chain tasks by passing outputs as inputs
8. Use available tools: {{.ToolsList}}
9. Type schemas are REQUIRED for all tasks (inputs/outputs hashes)
10. Use the agent name: "{{.AgentName}}"

**CRITICAL - VERIFY BEFORE OUTPUTTING:**
- ✓ Did you read and understand the USER INSTRUCTIONS above?
- ✓ Does your code IMPLEMENT those specific instructions?
- ✓ Are all task names, descriptions, and logic SPECIFIC to the user's request?
- ✓ Did you AVOID outputting placeholders like "task_name" or "CRON_EXPRESSION"?
- ✓ Does the code actually DO what the user asked for?

If you cannot answer YES to all of the above, re-read the user instructions and generate FUNCTIONAL code.

Generate the code now:
