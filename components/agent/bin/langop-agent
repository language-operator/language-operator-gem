#!/usr/bin/env ruby
# frozen_string_literal: true

# Langop Agent Entrypoint
#
# This script auto-loads synthesized agent code from a ConfigMap volume
# or falls back to default agent behavior if no code is provided.
#
# The operator synthesizes agent DSL code from natural language instructions
# and mounts it as a ConfigMap at AGENT_CODE_PATH.

# Disable output buffering for immediate log visibility
$stdout.sync = true
$stderr.sync = true

require 'language_operator'

# Wait for tool sidecars to be ready
def wait_for_tools(config)
  return unless config['mcp_servers']

  require 'net/http'
  require 'uri'

  servers = config['mcp_servers'] || []
  servers.each do |server|
    url = server['url']
    next unless url&.start_with?('http')

    uri = URI.parse(url)
    max_attempts = 30
    delay = 1

    puts "Waiting for tool at #{uri.host}:#{uri.port}..."

    max_attempts.times do |attempt|
      # Try to connect to the health endpoint or root
      Net::HTTP.start(uri.host, uri.port, open_timeout: 1, read_timeout: 1) do |http|
        http.head('/')
      end
      puts "Tool ready at #{uri.host}:#{uri.port}"
      break
    rescue StandardError
      if attempt < max_attempts - 1
        sleep(delay)
      else
        puts "Tool at #{uri.host}:#{uri.port} not ready after #{max_attempts} attempts"
      end
    end
  end
end

# Configuration
code_path = ENV.fetch('AGENT_CODE_PATH', '/etc/agent/code/agent.rb')
fallback_mode = ENV.fetch('AGENT_FALLBACK_MODE', 'error') # error | autonomous | interactive

# Check if synthesized code exists
if File.exist?(code_path)
  begin
    # Load the synthesized DSL code using the agent loader
    # This provides the DSL context with the 'agent' method
    LanguageOperator::Dsl.load_agent_file(code_path)

    # Get the agent from the registry
    agents = LanguageOperator::Dsl.agent_registry.all
    if agents.empty?
      puts 'No agent defined in code'
      exit 1
    end

    agent_def = agents.first

    # Execute the agent based on its definition using DSL v1 flow
    config = LanguageOperator::Client::Config.from_env
    agent = LanguageOperator::Agent::Base.new(config)

    # Wait for tool sidecars to be ready before connecting
    wait_for_tools(config)

    # Use the proper agent execution flow that handles DSL v1 main blocks, tasks, and output handlers
    LanguageOperator::Agent.run_with_definition(agent, agent_def)
  rescue StandardError => e
    puts "Error loading agent code: #{e.message}"
    puts e.backtrace.take(5).join("\n")

    case fallback_mode
    when 'autonomous'
      puts 'Falling back to autonomous mode with default config'
      fallback_to_autonomous
    when 'interactive'
      puts 'Falling back to interactive mode'
      fallback_to_interactive
    else
      puts 'No fallback configured, exiting'
      exit 1
    end
  end

else
  puts "No synthesized code found at #{code_path}"

  case fallback_mode
  when 'autonomous'
    puts 'Starting in autonomous mode with default config'
    fallback_to_autonomous
  when 'interactive'
    puts 'Starting in interactive mode'
    fallback_to_interactive
  else
    puts 'No agent code provided and no fallback configured'
    puts 'The operator should have created a ConfigMap with synthesized code'
    puts 'Check LanguageAgent status for synthesis errors'
    exit 1
  end
end

# Fallback implementations
def fallback_to_autonomous
  config = LanguageOperator::Client::Config.load_with_fallback
  agent = LanguageOperator::Agent::Base.new(config)

  # Get instructions from environment
  instructions = ENV.fetch('AGENT_INSTRUCTIONS', nil)

  if instructions && !instructions.empty?
    agent.connect!

    # Simple autonomous loop
    executor = LanguageOperator::Agent::Executor.new(agent)
    executor.execute(instructions)
  else
    puts 'No instructions provided in AGENT_INSTRUCTIONS'
    exit 1
  end
end

def fallback_to_interactive
  puts 'Interactive mode not yet implemented'
  exit 1
end
